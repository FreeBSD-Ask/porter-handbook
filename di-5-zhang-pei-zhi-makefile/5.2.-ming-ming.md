# 5.2.命名

在 port 的 **Makefile** 中的第一部分， 将命名这个 port， 描述它的版本号， 并将其列入正确的分类。

## 5.2.1. PORTNAME

将 `PORTNAME` 设为软件的基本名称。它被用作 FreeBSD 软件包的基础， 以及 `DISTNAME` 的基础。

> 重要
> 这个包的名字在整个 ports 树中必须是唯一的。请确保 `PORTNAME` 没有被现有的 port 使用， 并且没有其他 port 已经拥有相同的 `PKGBASE`。如果这个名字已经被使用了， 则应加入 `PKGNAMEPREFIX` 或 `PKGNAMESUFFIX`。

## 5.2.2. 版本，DISTVERSION 或 PORTVERSION

将 `DISTVERSION` 设为软件的版本号。

`PORTVERSION` 是用于 FreeBSD 软件包的版本。它将自动从 `DISTVERSION` 派生出来， 以便与 FreeBSD 的软件包版本计划兼容。如果版本包含字母，可能需要设置 `PORTVERSION` 而不是 `DISTVERSION`。

> 重要
> 每次只能设置 `PORTVERSION` 和 `DISTVERSION` 中的一个。

有时，一些软件会使用一个与 `DISTVERSION` 在 `PORTVERSION` 中的翻译方式不兼容的版本方案。

> 技巧
> 在更新 port 时， 可以使用 [pkg-version(8)](https://man.freebsd.org/cgi/man.cgi?query=pkg-version&sektion=8&format=html) 的 -t 参数来检查新版本是否大于或小于之前的版本。参见 [使用 pkg-version(8) 来比较版本](https://docs.freebsd.org/en/books/porters-handbook/book/#makefile-versions-ex-pkg-version)。

**例6. 使用 [pkg-version(8)](https://man.freebsd.org/cgi/man.cgi?query=pkg-version&sektion=8&format=html) 来比较版本**

> `pkg version -t` 接收两个版本作为参数，如果第一个版本比第二个版本少、等于或多，它将分别以 `<`、`=` 或 `>` 作为回应。
>
> ```
> % pkg version -t 1.2 1.3
> < ①
> % pkg version -t 1.2 1.2
> = ②
> % pkg version -t 1.2 1.2.0
> = ③
> % pkg version -t 1.2 1.2.p1
> > ④
> % pkg version -t 1.2.a1 1.2.b1
> < ⑤
> % pkg version -t 1.2 1.2p1
> < ⑥
> ```
>
> ① `1.2` 是在 `1.3` 之前。
>
> ② `1.2` 和 `1.2` 是平等的，因为它们的版本相同。
>
> ③ `1.2` 和 `1.2.0` 是相等的，因为没有什么等于零。
>
> ④ `1.2` 是在 `1.2.p1` 之后为 `.p1` ，认为是 "预发布1"。
>
> ⑤ `1.2.a1` 在 `1.2.b1` 之前，认为 "alpha" 和 "beta"，a 在 b 之前。
>
> ⑥ `1.2` 在 `1.2p1` 之前为 `2p1`，认为 "2，补丁级别1"，是任何 2.X 之后但 3 之前的版本。
>
> 在这里，a、b 和 p 被用来表示 "alpha"、"beta " 或 "pre-release "和 "patch level"，但它们只是字母，而且是按字母排序的，所以可以使用任何字母，它们会被适当排序。

表1. `DISTVERSION` 和派生 `PORTVERSION` 的例子

| DISTVERSION | PORTVERSION |
| :---------: | :---------: |
|   0.7.1d    |   0.7.1.d   |
|  10Alpha3   |    10.a3    |
| 3Beta7-pre2 |   3.b7.p2   |
|   8:f_17    |    8f.17    |

**例7. 使用 `DISTVERSION`**

> 当版本只包含由点、破折号或下划线分隔的数字时，使用 `DISTVERSION`。
>
> > ```
> > PORTNAME=   nekoto
> > DISTVERSION=	1.2-4
> > ```
> 
> 它将产生一个 `1.2.4` 的 `PORTVERSION`。
> 

**例8. 当版本以字母或前缀开头时使用 `DISTVERSION`**

> 当版本以字母开始或结束，或者前缀或后缀不是版本的一部分时，使用 `DISTVERSIONPREFIX`、`DISTVERSION` 和 `DISTVERSIONSUFFIX`。
>
> 如果版本是 `v1.2-4`：
>
> ```
> PORTNAME=   nekoto
> DISTVERSIONPREFIX=  v
> DISTVERSION=	1_2_4
> ```
>
> 有些时候，使用 GitHub 的项目会在其版本中使用其名称。例如，版本可能是 `nekoto-1.2-4`：
>
> ```
> PORTNAME=   nekoto
> DISTVERSIONPREFIX=  nekoto-
> DISTVERSION=	1.2_4
> ```
>
> 那些项目有时也会在版本的末尾使用一些字符串，例如 `1.2-4_RELEASE`：
>
> ```
> PORTNAME=   nekoto
> DISTVERSION=	1.2-4
> DISTVERSIONSUFFIX=  _RELEASE
> ```
>
> `DISTVERSIONPREFIX` 和 `DISTVERSIONSUFFIX` 在构建 `PORTVERSION` 时不会被使用，而只在 `DISTNAME` 中使用。
>
> 所有这些都将产生一个1.2.4的 `PORTVERSION`。

**例9. 当版本含有  "alpha"、"beta " 或  "pre-release " 的字母时使用 `DISTVERSION`。**

> 当版本包含由点、破折号或下划线隔开的数字，并且用字母表示 "alpha"、"beta "或 "pre-release"，也就是在没有字母的版本之前，使用 `DISTVERSION`。
>
> ```
> PORTNAME=   nekoto
> DISTVERSION=	1.2-pre4
> ```
>
> ```
> PORTNAME=   nekoto
> DISTVERSION=	1.2p4
> ```
>
> 两者都会产生一个 `1.2.p4` 的 `PORTVERSION`， 它比 1.2 早。 [pkg-version(8)](https://man.freebsd.org/cgi/man.cgi?query=pkg-version&sektion=8&format=html) 可以用来检查这个事实：
>
> ```
> % pkg version -t 1.2.p4 1.2
> <
> ```

**例10. 当版本包含意味着 "补丁级别" 的字母时不使用 `DISTVERSION`**

> 当版本包含的字母不是指 "alpha"、"beta "或 "pre"，而更多的是指 "补丁级别"，并且是指在没有字母的版本之后，使用 `PORTVERSION`。
>
> ```
> PORTNAME=   nekoto
> PORTVERSION=	1.2p4
> ```
>
> 在这种情况下， 使用 `DISTVERSION` 是不可能的， 因为它会生成一个 `1.2.p4` 的版本， 而这个版本会在 `1.2` 之前而不是之后。 [pkg-version(8)](https://man.freebsd.org/cgi/man.cgi?query=pkg-version&sektion=8&format=html) 会验证这一点：
>
> ```
> % pkg version -t 1.2 1.2.p4
> > ①
> % pkg version -t 1.2 1.2p4
> < ②
> ```
>
> ① `1.2` 是在 `1.2.p4` 之后，在这种情况下是错误的。
>
> ② `1.2` 是在 `1.2p4` 之前，这就是需要的。

关于一些更高级的设置 `PORTVERSION` 的例子， 当软件的版本控制确实与 FreeBSD 的不兼容时， 或当发行文件不包含版本本身时， 请参阅 `DISTNAME`。

## 5.2.3. `PORTREVISION` 和 `PORTEPOCH`

### 5.2.3.1. `PORTREVISION`

`PORTREVISION` 是一个单调增加的值，随着 `DISTVERSION` 的增加而被重置为 0，通常是在每次有新的官方厂商发布时。如果 `PORTREVISION` 不是零，这个值就会附加到软件包的名称上。`PORTREVISION` 的变化会被像 [pkg-version(8)](https://man.freebsd.org/cgi/man.cgi?query=pkg-version&sektion=8&format=html) 这样的自动化工具用来确定一个新的软件包是否可用。

`PORTREVISION` 必须在每次对 ports 进行修改并以任何方式改变生成的包时增加。这包括那些只影响到用非默认选项构建的软件包的变化。

`PORTREVISION` 必须被撞的例子：

- 增加补丁以纠正安全漏洞、错误，或为 ports 增加新功能。
- 修改 port 的 **Makefile** 以启用或禁用软件包中的编译时选项。
- 包装清单或软件包安装时行为的改变。例如， 对为软件包生成初始数据的脚本的改变， 如 [ssh(1)](https://man.freebsd.org/cgi/man.cgi?query=ssh&sektion=1&format=html) 主机密钥。
- 一个 port 的共享库依赖关系的版本突变 (在这种情况下， 有人在安装了依赖关系的较新版本之后试图安装旧的软件包会失败， 因为它会寻找旧的 libfoo.x 而不是 libfoo. (x+1))。
- 对 port distfile 所做的无声的改动， 而这些改动在功能上有明显的差异。例如， 对 distfile 的修改需要对 **distinfo** 进行修正， 而对 `DISTVERSION` 没有相应的改动， 在新旧版本的 `diff -ru` 中显示了代码的非重大变化。

不需要 `PORTREVISION` 碰撞的变化实例：

- 对 ports 骨架的样式进行修改，但对出现在结果包中的内容没有功能上的改变。
- 对 `MASTER_SITES` 的修改或对 ports 的其他功能修改， 并不影响所产生的包。
- 对  distfile 进行琐碎的修补，例如改正错别字，这些修补并不重要，以至于软件包的用户必须费尽心思去升级。
- 导致软件包在以前无法编译的地方变得可以编译的编译修复。只要这些修改没有在任何其他平台上引入任何功能上的变化， 而这些平台上的 port 之前确实是可以编译的。由于 `PORTREVISION` 反映了软件包的内容， 如果这个软件包以前是不可编译的， 那么就没有必要增加 `PORTREVISION` 来标记一个变化。
- 对 `MAINTAINER` 的改变。

一个经验法则是， 要确定提交给 port 的修改是否能让一些人受益。无论是因为增强、修复，还是因为新的软件包能够实际工作。然后再权衡一下， 这是否会导致所有定期更新他们的 ports 树的人被迫更新。如果是的话， `PORTREVISION` 就必须被提升。

> 注意
> 如果不提高 `PORTREVISION`，使用二进制包的人将永远看不到更新。如果不增加 `PORTREVISION`，软件包制作者就没有办法检测到这个变化，因此也就不会重建软件包。

### 5.2.3.2. `PORTEPOCH`

有时， 软件供应商或 FreeBSD 移植者会做一些愚蠢的事情， 发布他们的软件的一个版本， 而这个版本实际上在数字上小于前一个版本。这方面的一个例子是一个从 foo-20000801 到 foo-1.0 的 port (前者会被错误地视为较新的版本， 因为 20000801 在数值上大于 1)。

> 技巧
> 版本号比较的结果并不总是显而易见的。 pkg 版本（见 [pkg-version(8)](https://man.freebsd.org/cgi/man.cgi?query=pkg-version&sektion=8&format=html)）可以用来测试两个版本号字符串的比较。比如说
>
> ```
> % pkg version -t 0.031 0.29
> >
> ```
>
> `>` 输出表明，0.031 版本被认为大于 0.29 版本，这对搬运工来说可能并不明显。

在这样的情况下， `PORTEPOCH` 必须被增加。如果 `PORTEPOCH` 非零， 就会像上面第 0 节所述的那样， 附加到软件包的名称上。`PORTEPOCH` 绝不能减少或重置为零， 因为这将导致与早期的包的比较失败。例如， 这个包将不会被检测到是过时的。新的版本号， 在上面的例子中是 `1.0,1`， 在数字上仍然小于先前的版本， 20000801， 但自动工具会对后缀 `,1` 进行特殊处理， 并发现它大于先前软件包上的隐含后缀 `,0`。

错误地丢弃或重设` PORTEPOCH` 会导致无尽的痛苦。如果上面的讨论还不够清楚， 请参考 [FreeBSD ports 邮件列表](https://lists.freebsd.org/subscription/freebsd-ports)。

我们希望 `PORTEPOCH` 不会被用于大多数的 port， 而合理地使用 `DISTVERSION`， 或谨慎地使用 `PORTVERSION`， 通常可以在未来的软件发布时避免它成为必要的版本结构。然而， 当供应商发布的版本没有正式的版本号时 -- 例如代码 "快照 "版本， FreeBSD 移植者需要小心。诱人的做法是在发行版上标上发行日期， 这将导致在上面的例子中出现新的 "官方" 发行版的问题。

例如， 如果一个快照的发布日期是 `20000917`， 而软件的前一个版本是 `1.2` 版， 不要用 `20000917` 来表示 `DISTVERSION`。正确的方法是使用 `1.2.20000917` 或类似的 `DISTVERSION`，这样后续的版本，例如  `1.3`，在数字上还是一个更大的值。

### 5.2.3.3. `PORTREVISION` 和 `PORTEPOCH` 的使用实例

`gtkmumble` port， 版本 `0.10`， 已提交给 Ports ：

```
PORTNAME=	gtkmumble
DISTVERSION=	0.10
```

`PKGNAME` 变成 `gtkmumble-0.10`。

发现了一个安全漏洞， 需要一个本地的 FreeBSD 补丁。`PORTREVISION` 也相应地进行了修改。

```
PORTNAME=	gtkmumble
DISTVERSION=	0.10
PORTREVISION=	1
```

`PKGNAME` 变成 `gtkmumble-0.10_1`

厂商发布了一个新的版本，编号为 `0.2`（原来作者的意思是 `0.10` 实际上是指 `0.1.0`，而不是 "0.9之后的东西" - 哎呀，现在太晚了）。由于新的次要版本 `2` 在数字上小于之前的版本 `10`，所以必须对 `PORTEPOCH` 进行撞击，以手动方式迫使新的软件包被检测为 "较新"。由于这是一个新的供应商发布的代码，`PORTREVISION` 被重置为 0 (或从 **Makefile** 中删除)。

```
PORTNAME=	gtkmumble
DISTVERSION=	0.2
PORTEPOCH=	1
```

`PKGNAME` 变成 `gtkmumble-0.2,1`

下一个版本是0.3。由于 `PORTEPOCH` 从未减少，现在的版本变量是：

```
PORTNAME=	gtkmumble
DISTVERSION=	0.3
PORTEPOCH=	1
```

`PKGNAME` 变成 `gtkmumble-0.3,1`

> 注意
> 如果 `PORTEPOCH` 在这次升级中被重置为 `0`， 那么安装了 `gtkmumble-0.10_1` 包的人就不会发现 `gtkmumble-0.3` 包是新的， 因为 `3` 在数字上仍然小于 `10`。记住，这就是 `PORTEPOCH` 的全部意义所在。

## 5.2.4. `PKGNAMEPREFIX` 和 `PKGNAMESUFFIX`

两个可选的变量，`PKGNAMEPREFIX` 和 `PKGNAMESUFFIX`， 会与 `PORTNAME` 和 `PORTVERSION` 结合起来， 形成 `PKGNAME`， 即 `${PKGNAMEPREFIX}${PORTNAME}${PKGNAMESUFFIX}-${PORTVERSION}`。请确保这符合我们对一个好的软件包名称的指导原则。特别是， 在 `PORTVERSION` 中不允许使用连字符 (-) 。此外， 如果包的名字中有语言或 -compiled.specifics 部分 (见下文)， 则应分别使用 `PKGNAMEPREFIX` 和 `PKGNAMESUFFIX`。不要让它们成为 `PORTNAME` 的一部分。

## 5.2.5. 包的命名规则

这些是命名软件包时要遵循的惯例。这是为了使软件包目录易于扫描，因为已经有成千上万的软件包，用户如果伤了眼睛，就会转身离开

包的名称采取 **语言_地区名称-编译.具体-版本.数字** 的形式。

软件包名称定义为 `${PKGNAMEPREFIX}${PORTNAME}${PKGNAMESUFFIX}-${PORTVERSION}`。请确保设置的变量符合这一格式。

**语言_区域-**

FreeBSD 努力支持其用户的母语。语言部分是由ISO-639定义的自然语言的两个字母缩写， 当 port 是针对某种语言的时候。例如， `ja` 代表日语， `ru` 代表俄语， `vi` 代表越南语， `zh` 代表中文， `ko` 代表韩语， `de` 代表德语。

如果 ports 是特定于语言区域内的某一地区的， 也要加上两个字母的国家代码。例如，`en_US` 代表美国英语，`fr_CH` 代表瑞士法语。

语言部分是在 `PKGNAMEPREFIX` 中设置的。

**名称**

请确保将 port 的名字和版本清楚地分开， 并放在 `PORTNAME` 和 `DISTVERSION` 中。`PORTNAME` 包含版本部分的唯一原因是上游发行版确实是这样命名的， 如 [textproc/libxml2](https://cgit.freebsd.org/ports/tree/textproc/libxml2/) 或 [japanese/kinput2-freewnn](https://cgit.freebsd.org/ports/tree/japanese/kinput2-freewnn/) port。否则，`PORTNAME` 就不能包含任何特定的版本信息。几个 port 拥有相同的 `PORTNAME` 是很正常的， 就像 [www/apache*](https://cgit.freebsd.org/ports/tree/www/apache*/) port 那样； 在这种情况下， 不同的版本 (以及不同的索引条目) 会通过 `PKGNAMEPREFIX` 和 `PKGNAMESUFFIX` 值来区分。

命名 `Perl 5` 模块有一个传统，即在模块前加 `p5-`，并将双冒号分隔符转换为连字符。例如，`Data::Dumper` 模块成为 `p5-Data-Dumper`。

-已编译的.具体内容

如果 port 可以用不同的硬编码默认值来联编 (通常是 port 家族中目录名称的一部分)， 则 -compiled.specifics 部分会说明编译后的默认值。连字符是可选的。例如， 纸张大小和字体单位。

-compiled.specifics 部分在 `PKGNAMESUFFIX` 中设置。

**-版本.数字**

版本字符串在破折号（`-`）之后，是一个由整数和单个小写字母组成的句点分隔的列表。特别是，不允许在版本字符串中再出现一个破折号。唯一的例外是字符串 `pl`（意思是 "补丁级别"），它只能在软件中没有主要和次要版本号时使用。如果软件的版本有 "alpha"、"beta"、"rc "或 "pre "这样的字符串，取第一个字母并将其放在句号之后。如果版本字符串在这些名称之后继续，则数字跟随单字母，中间不加句号（例如，`1.0b2`）。

这个想法是为了使通过查看版本字符串来对 ports 进行排序变得更容易。特别是要确保版本号组件总是以句点为界， 如果日期是字符串的一部分， 则应使用 `dyyyy.mm.dd` 格式， 而不是 `dd.mm.yyyy` 或不符合千年标准的 `yy.mm.dd` 格式。重要的是要在版本前加一个字母，这里是 d（代表日期），以备有实际版本号的版本发布时，在数字上会小于 `yyyy`。

> 重要
> 在所有的 ports 树中， 包的名字必须是唯一的， 检查是否已经有一个具有相同 `PORTNAME` 的 port， 如果有， 则应添加 `PKGNAMEPREFIX` 或 `PKGNAMESUFFIX` 中的一个。

下面是一些关于如何将软件作者所叫的名字转换成合适的包名的(真实的)例子， 对于每一行， 只设置了 `DISTVERSION` 或 `PORTVERSION` 中的一个， 这取决于在 port 的 **Makefile** 中会使用哪个：

**表2. 包的命名示例**

|    分布名称     | PKGNAMEPREFIX | PORTNAME | PKGNAMESUFFIX | DISTVERSION | PORTVERSION |                          原因或评价                          |
| :-------------: | :-----------: | :------: | :-----------: | :---------: | :---------: | :----------------------------------------------------------: |
|   mule-2.2.2    |    (empty)    |   mule   |    (empty)    |    2.2.2    |             |                          不需要改变                          |
|   mule-1.0.1    |    (empty)    |   mule   |       1       |    1.0.1    |             |         这是 mule 的第一个版本，第二个版本已经存在了         |
| EmiClock-1.0.2  |    (empty)    | emiclock |    (empty)    |    1.0.2    |             |                   单个程序没有大写字母名称                   |
| rdist-1.3alpha  |    (empty)    |  rdist   |    (empty)    |  1.3alpha   |             |                      版本将是`1.3.a`。                       |
|  es-0.9-beta1   |    (empty)    |    es    |    (empty)    |  0.9-beta1  |             |                     版本将是 `0.9.b1`。                      |
| mailman-2.0rc3  |    (empty)    | mailman  |    (empty)    |   2.0rc3    |             |                      版本将是`2.0.r3`。                      |
| v3.3beta021.src |    (empty)    |   tiff   |    (empty)    |             |     3.3     |                      那到底是什么东西？                      |
|      tvtwm      |    (empty)    |  tvtwm   |    (empty)    |             |     p11     |            文件名中没有版本，使用上游所说的版本。            |
|      piewm      |    (empty)    |  piewm   |    (empty)    |     1.0     |             |            文件名中没有版本，使用上游所说的版本。            |
|  xvgr-2.10pl1   |    (empty)    |   xvgr   |    (empty)    |             |  2.10.pl1   | 在这种情况下，`pl1`意味着补丁级别，所以使用 `DISTVERSION` 是不可能的。 |
|   gawk-2.15.6   |      ja-      |   gawk   |    (empty)    |   2.15.6    |             |                           日语版本                           |
|  psutils-1.13   |    (empty)    | psutils  |    -letter    |    1.13     |             |                 在软件包建立时硬编码纸张尺寸                 |
|     pkfonts     |    (empty)    | pkfonts  |      300      |     1.0     |             |                       300dpi字体的包装                       |

如果在原始源文件中完全没有版本信息的痕迹，而且原作者也不可能再发布另一个版本，那么就把版本字符串设为 `1.0`（就像上面的 `piewm` 例子）。否则，请询问原作者或使用源文件发布的日期字符串（ `yyyy.mm.dd`，或 `yyyymmdd` ）作为版本。

> 技巧
> 使用任何字母。这里，`d` 代表日期，如果源是 Git 仓库，通常使用 `g` 后面的提交日期，使用 `s` 代表快照也很常见。
